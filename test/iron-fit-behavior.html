<!doctype html>
<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<html>
  <head>

    <title>iron-fit-behavior tests</title>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1, user-scalable=yes">

    <script>
      WCT = {
        mochaOptions: {timeout: Infinity}
      }
    </script>

    <script src="../node_modules/@webcomponents/webcomponentsjs/webcomponents-bundle.js"></script>
    <script src="../node_modules/wct-browser-legacy/browser.js"></script>

    <style>
      body {
        margin: 0;
        padding: 0;
      }

      .absolute {
        position: absolute;
        top: 0;
        left: 0;
      }

      .scrolling {
        overflow: auto;
      }

      .sized-x {
        width: 100px;
      }

      .sized-y {
        height: 100px;
      }

      .positioned-left {
        position: absolute;
        left: 100px;
      }

      .positioned-right {
        position: absolute;
        right: 100px;
      }

      .positioned-top {
        position: absolute;
        top: 100px;
      }

      .positioned-bottom {
        position: absolute;
        bottom: 100px;
      }

      .with-max-width {
        max-width: 500px;
      }

      .with-max-height {
        max-height: 500px;
      }

      .with-margin {
        margin: 20px;
      }

      .constrain {
        position: fixed;
        top: 20px;
        left: 20px;
        width: 150px;
        height: 150px;
        border: 1px solid black;
        box-sizing: border-box;
      }

      #nearTop {
        position: fixed;
        left: 50%;
        top: 32px;
        width: 32px;
        height: 32px;
        border: 1px dashed black;
      }

      #nearRight {
        position: fixed;
        right: 32px;
        top: 50%;
        width: 32px;
        height: 32px;
        border: 1px dashed black;
      }

      #nearBottom {
        position: fixed;
        left: 50%;
        bottom: 32px;
        width: 32px;
        height: 32px;
        border: 1px dashed black;
      }

      #nearLeft {
        position: fixed;
        left: 32px;
        top: 50%;
        width: 32px;
        height: 32px;
        border: 1px dashed black;
      }

      .sizer {
        width: 9999px;
        height: 9999px;
      }
    </style>
  </head>
  <body>
    <div class="constrain"></div>

    <div id="nearTop"></div>
    <div id="nearRight"></div>
    <div id="nearBottom"></div>
    <div id="nearLeft"></div>

    <test-fixture id="basic">
      <template>
        <test-fit>
          Basic
        </test-fit>
      </template>
    </test-fixture>

    <test-fixture id="absolute">
      <template>
        <test-fit auto-fit-on-attach class="absolute">
          Absolutely positioned
        </test-fit>
      </template>
    </test-fixture>

    <test-fixture id="sized-xy">
      <template>
        <test-fit auto-fit-on-attach class="sized-x sized-y">
          Sized (x/y), auto center/center
        </test-fit>
      </template>
    </test-fixture>

    <test-fixture id="sized-x">
      <template>
        <test-fit auto-fit-on-attach class="sized-x">
          Sized (x), auto center/center
        </test-fit>
      </template>
    </test-fixture>

    <test-fixture id="positioned-xy">
      <template>
        <test-fit auto-fit-on-attach class="sized-x positioned-left positioned-top">
          Sized (x/y), positioned/positioned
        </test-fit>
      </template>
    </test-fixture>

    <test-fixture id="inline-positioned-xy">
      <template>
        <test-fit auto-fit-on-attach class="sized-x sized-y" style="position:absolute;left:100px;top:100px;">
          Sized (x/y), positioned/positioned
        </test-fit>
      </template>
    </test-fixture>

    <test-fixture id="sectioned">
      <template>
        <test-fit auto-fit-on-attach class="sized-x">
          <div>
            Sized (x), auto center/center with scrolling section
          </div>
          <div class="internal"></div>
        </test-fit>
      </template>
    </test-fixture>

    <test-fixture id="constrain-target">
      <template>
        <div class="constrain">
          <test-fit auto-fit-on-attach class="el sized-x sized-y">
            <div>
              Auto center/center to parent element
            </div>
          </test-fit>
        </div>
      </template>
    </test-fixture>

    <test-fixture id="offscreen-container">
      <template>
        <div style="position: fixed; top: -1px; left: 0;">
          <test-fit auto-fit-on-attach class="el sized-x">
            <div>
              Sized (x), auto center/center, container is offscreen
            </div>
          </test-fit>
        </div>
      </template>
    </test-fixture>

    <test-fixture id="scrollable">
      <template>
        <test-fit auto-fit-on-attach class="scrolling">
          scrollable
          <div class="sizer"></div>
        </test-fit>
      </template>
    </test-fixture>

    <test-fixture id="expandSizingTargetForScrollbars">
      <template>
        <test-fit expand-sizing-target-for-scrollbars class="scrolling">
          scrollable
        </test-fit>
      </template>
    </test-fixture>

    <template id="ipsum">
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
    </template>

    <script type="module">
      import './test-fit.js';
      import {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';

      function makeScrolling(el) {
        el.classList.add('scrolling');
        var template = document.getElementById('ipsum');
        for (var i = 0; i < 20; i++) {
          el.appendChild(template.content.cloneNode(true));
        }
      }

      function intersects(r1, r2) {
        return !(
            r2.left >= r1.right || r2.right <= r1.left || r2.top >= r1.bottom ||
            r2.bottom <= r1.top);
      }

      // Firefox and Safari have a bug where elements with `overflow: auto;` and
      // width based on their content's natural size (e.g. `position: fixed;`,
      // `display: inline-block;`) will have their scrollbar rendered
      // overlapping the content. Chrome actually also exhibits a similar bug
      // but doesn't display the scrollbar here or in the state measured during
      // the tests, so this ends up being sufficient to distinguish these cases.
      //
      // https://bugzilla.mozilla.org/show_bug.cgi?id=764076
      // https://bugs.webkit.org/show_bug.cgi?id=17309
      const hasOverflowAutoWidthBug = (() => {
        const container = document.createElement('div');
        Object.assign(container.style, {
          overflow: 'auto',
          position: 'fixed',
          left: '0px',
          top: '0px',
          maxHeight: '100px',
        });
        container.appendChild(document.createTextNode('ThisTextCantBeBroken'));

        const content = document.createElement('div');
        content.style.height = '200px';
        container.appendChild(content);

        document.body.appendChild(container);
        const hasOverflowAutoWidthBug =
            (container.offsetHeight - container.clientHeight) > 0;
        document.body.removeChild(container);

        return hasOverflowAutoWidthBug;
      })();

      // IE11 has a bug where an element with (1) `overflow: auto;`, (2) size
      // based on its content's natural size, (3) absolute positioning (either
      // `absolute` or `fixed`), and (4) use `max-width` to constrain its width
      // will place its vertical scrollbar outside the area constrained by
      // `max-width`.
      const hasVerticalScrollbarMaxWidthBug = (() => {
        const container = document.createElement('div');
        Object.assign(container.style, {
          overflow: 'auto',
          position: 'fixed',
          left: '0px',
          top: '0px',
          maxWidth: '100px',
          maxHeight: '100px',
        });

        const content = document.createElement('div');
        content.style.width = '200px';
        content.style.height = '200px';
        container.appendChild(content);

        document.body.appendChild(container);
        const hasVerticalScrollbarMaxWidthBug =
            Math.abs(container.offsetWidth - 100) > 1;
        document.body.removeChild(container);

        return hasVerticalScrollbarMaxWidthBug;
      })();

      const scrollbarSize = (() => {
        const container = document.createElement('div');
        Object.assign(container.style, {
          overflow: 'auto',
          position: 'fixed',
          left: '0px',
          top: '0px',
          maxWidth: '100px',
          maxHeight: '100px',
        });

        const content = document.createElement('div');
        content.style.width = '200px';
        content.style.height = '200px';
        container.appendChild(content);

        document.body.appendChild(container);
        const width = container.offsetWidth - container.clientWidth;
        const height = container.offsetHeight - container.clientHeight;
        document.body.removeChild(container);

        return {width, height};
      })();

      suite('basic', function() {
        var el;
        setup(function() {
          el = fixture('basic');
        });

        test('position() works without autoFitOnAttach', function() {
          el.verticalAlign = 'top';
          el.horizontalAlign = 'left';
          el.position();
          var rect = el.getBoundingClientRect();
          assert.equal(rect.top, 0, 'top ok');
          assert.equal(rect.left, 0, 'left ok');
        });

        test('constrain() works without autoFitOnAttach', function() {
          el.constrain();
          var style = getComputedStyle(el);
          assert.equal(style.maxWidth, window.innerWidth + 'px', 'maxWidth ok');
          assert.equal(style.maxHeight, window.innerHeight + 'px', 'maxHeight ok');
        });

        test('center() works without autoFitOnAttach', function() {
          el.center();
          var rect = el.getBoundingClientRect();
          assert.closeTo(
              rect.left - (window.innerWidth - rect.right),
              0,
              5,
              'centered horizontally');
          assert.closeTo(
              rect.top - (window.innerHeight - rect.bottom),
              0,
              5,
              'centered vertically');
        });
      });

      suite('manual positioning', function() {
        test('css positioned element is not re-positioned', function() {
          var el = fixture('positioned-xy');
          var rect = el.getBoundingClientRect();
          assert.equal(rect.top, 100, 'top is unset');
          assert.equal(rect.left, 100, 'left is unset');
        });

        test('inline positioned element is not re-positioned', function() {
          var el = fixture('inline-positioned-xy');
          var rect = el.getBoundingClientRect();
          // need to measure document.body here because mocha sets a min-width on
          // html,body, and the element is positioned wrt to that by css
          var bodyRect = document.body.getBoundingClientRect();
          assert.equal(rect.top, 100, 'top is unset');
          assert.equal(rect.left, 100, 'left is unset');

          el.refit();

          rect = el.getBoundingClientRect();
          assert.equal(rect.top, 100, 'top is unset after refit');
          assert.equal(rect.left, 100, 'left is unset after refit');
        });

        test('position property is preserved after', function() {
          var el = fixture('absolute');
          assert.equal(
              getComputedStyle(el).position,
              'absolute',
              'position:absolute is preserved');
        });
      });

      suite('fit to window', function() {
        test('sized element is centered in viewport', function() {
          var el = fixture('sized-xy');
          var rect = el.getBoundingClientRect();
          assert.closeTo(
              rect.left - (window.innerWidth - rect.right),
              0,
              5,
              'centered horizontally');
          assert.closeTo(
              rect.top - (window.innerHeight - rect.bottom),
              0,
              5,
              'centered vertically');
        });

        test('sized element with margin is centered in viewport', function() {
          var el = fixture('sized-xy');
          el.classList.add('with-margin');
          el.refit();
          var rect = el.getBoundingClientRect();
          assert.closeTo(
              rect.left - (window.innerWidth - rect.right),
              0,
              5,
              'centered horizontally');
          assert.closeTo(
              rect.top - (window.innerHeight - rect.bottom),
              0,
              5,
              'centered vertically');
        });

        test(
            'sized element with transformed parent is centered in viewport',
            function() {
              var constrain = fixture('constrain-target');
              var el = dom(constrain).querySelector('.el');
              var rectBefore = el.getBoundingClientRect();
              constrain.style.transform = 'translate3d(5px, 5px, 0)';
              el.center();
              var rectAfter = el.getBoundingClientRect();
              assert.equal(rectBefore.top, rectAfter.top, 'top ok');
              assert.equal(rectBefore.bottom, rectAfter.bottom, 'bottom ok');
              assert.equal(rectBefore.left, rectAfter.left, 'left ok');
              assert.equal(rectBefore.right, rectAfter.right, 'right ok');
            });

        test('scrolling element is centered in viewport', function() {
          var el = fixture('sized-x');
          makeScrolling(el);
          el.refit();
          var rect = el.getBoundingClientRect();
          assert.closeTo(
              rect.left - (window.innerWidth - rect.right),
              0,
              5,
              'centered horizontally');
          assert.closeTo(
              rect.top - (window.innerHeight - rect.bottom),
              0,
              5,
              'centered vertically');
        });

        test('scrolling element is constrained to viewport height', function() {
          var el = fixture('sized-x');
          makeScrolling(el);
          el.refit();
          var rect = el.getBoundingClientRect();
          assert.isTrue(
              rect.height <= window.innerHeight,
              'height is less than or equal to viewport height');
        });

        test(
            'scrolling element with offscreen container is constrained to viewport height',
            function() {
              var container = fixture('offscreen-container');
              var el = dom(container).querySelector('.el')
              makeScrolling(el);
              el.refit();
              var rect = el.getBoundingClientRect();
              assert.isTrue(
                  rect.height <= window.innerHeight,
                  'height is less than or equal to viewport height');
            });

        test('scrolling element with max-height is centered in viewport', function() {
          var el = fixture('sized-x');
          el.classList.add('with-max-height');
          makeScrolling(el);
          el.refit();
          var rect = el.getBoundingClientRect();
          assert.closeTo(
              rect.left - (window.innerWidth - rect.right),
              0,
              5,
              'centered horizontally');
          assert.closeTo(
              rect.top - (window.innerHeight - rect.bottom),
              0,
              5,
              'centered vertically');
        });

        test('scrolling element with max-height respects max-height', function() {
          var el = fixture('sized-x');
          el.classList.add('with-max-height');
          makeScrolling(el);
          el.refit();
          var rect = el.getBoundingClientRect();
          assert.isTrue(
              rect.height <= 500, 'height is less than or equal to max-height');
        });

        test(
            'css positioned, scrolling element is constrained to viewport height (top,left)',
            function() {
              var el = fixture('positioned-xy');
              makeScrolling(el);
              el.refit();
              var rect = el.getBoundingClientRect();
              assert.isTrue(
                  rect.height <= window.innerHeight - 100,
                  'height is less than or equal to viewport height');
            });

        test(
            'css positioned, scrolling element is constrained to viewport height (bottom, right)',
            function() {
              var el = fixture('sized-x');
              el.classList.add('positioned-bottom');
              el.classList.add('positioned-right');
              el.refit();
              var rect = el.getBoundingClientRect();
              assert.isTrue(
                  rect.height <= window.innerHeight - 100,
                  'height is less than or equal to viewport height');
            });

        test(
            'sized, scrolling element with margin is centered in viewport',
            function() {
              var el = fixture('sized-x');
              el.classList.add('with-margin');
              makeScrolling(el);
              el.refit();
              var rect = el.getBoundingClientRect();
              assert.closeTo(
                  rect.left - (window.innerWidth - rect.right),
                  0,
                  5,
                  'centered horizontally');
              assert.closeTo(
                  rect.top - (window.innerHeight - rect.bottom),
                  0,
                  5,
                  'centered vertically');
            });

        test(
            'sized, scrolling element is constrained to viewport height', function() {
              var el = fixture('sized-x');
              el.classList.add('with-margin');
              makeScrolling(el);
              el.refit();
              var rect = el.getBoundingClientRect();
              assert.isTrue(
                  rect.height <= window.innerHeight - 20 * 2,
                  'height is less than or equal to viewport height');
            });

        test(
            'css positioned, scrolling element with margin is constrained to viewport height (top, left)',
            function() {
              var el = fixture('positioned-xy');
              el.classList.add('with-margin');
              makeScrolling(el);
              el.refit();
              var rect = el.getBoundingClientRect();
              assert.isTrue(
                  rect.height <= window.innerHeight - 100 - 20 * 2,
                  'height is less than or equal to viewport height');
            });

        test(
            'css positioned, scrolling element with margin is constrained to viewport height (bottom, right)',
            function() {
              var el = fixture('sized-x');
              el.classList.add('positioned-bottom');
              el.classList.add('positioned-right');
              el.classList.add('with-margin')
              el.refit();
              var rect = el.getBoundingClientRect();
              assert.isTrue(
                  rect.height <= window.innerHeight - 100 - 20 * 2,
                  'height is less than or equal to viewport height');
            });

        test('scrolling sizingTarget is constrained to viewport height', function() {
          var el = fixture('sectioned');
          var internal = dom(el).querySelector('.internal');
          el.sizingTarget = internal;
          makeScrolling(internal);
          el.refit();
          var rect = el.getBoundingClientRect();
          assert.isTrue(
              rect.height <= window.innerHeight,
              'height is less than or equal to viewport height');
        });

        test('scrolling sizingTarget preserves scrolling position', function() {
          var el = fixture('scrollable');
          el.scrollTop = 20;
          el.scrollLeft = 20;
          el.refit();
          assert.equal(el.scrollTop, 20, 'scrollTop ok');
          assert.equal(el.scrollLeft, 20, 'scrollLeft ok');
        });
      });

      suite('fit to element', function() {
        test('element fits in another element', function() {
          var constrain = fixture('constrain-target');
          var el = dom(constrain).querySelector('.el')
          makeScrolling(el);
          el.fitInto = constrain;
          el.refit();
          var rect = el.getBoundingClientRect();
          var crect = constrain.getBoundingClientRect();
          assert.isTrue(
              rect.height <= crect.height,
              'width is less than or equal to fitInto width');
          assert.isTrue(
              rect.height <= crect.height,
              'height is less than or equal to fitInto height');
        });

        test('element centers in another element', function() {
          var constrain = fixture('constrain-target');
          var el = dom(constrain).querySelector('.el');
          makeScrolling(el);
          el.fitInto = constrain;
          el.refit();
          var rect = el.getBoundingClientRect();
          var crect = constrain.getBoundingClientRect();
          assert.closeTo(
              rect.left - crect.left - (crect.right - rect.right),
              0,
              5,
              'centered horizontally in fitInto');
          assert.closeTo(
              rect.top - crect.top - (crect.bottom - rect.bottom),
              0,
              5,
              'centered vertically in fitInto');
        });

        test('element with max-width centers in another element', function() {
          var constrain = document.querySelector('.constrain');
          var el = fixture('sized-xy');
          el.classList.add('with-max-width');
          el.fitInto = constrain;
          el.refit();
          var rect = el.getBoundingClientRect();
          var crect = constrain.getBoundingClientRect();
          assert.closeTo(
              rect.left - crect.left - (crect.right - rect.right),
              0,
              5,
              'centered horizontally in fitInto');
          assert.closeTo(
              rect.top - crect.top - (crect.bottom - rect.bottom),
              0,
              5,
              'centered vertically in fitInto');
        });

        test('positioned element fits in another element', function() {
          var constrain = document.querySelector('.constrain');
          // element's positionTarget is `body`, and fitInto is `constrain`.
          var el = fixture('sized-xy');
          el.verticalAlign = 'top';
          el.horizontalAlign = 'left';
          el.fitInto = constrain;
          el.refit();
          var rect = el.getBoundingClientRect();
          var crect = constrain.getBoundingClientRect();
          assert.equal(rect.top, crect.top, 'top ok');
          assert.equal(rect.left, crect.left, 'left ok');
        });
      });

      suite('horizontal/vertical align', function() {
        var parent, parentRect;
        var el, elRect;
        var fitRect = {
          left: 0,
          top: 0,
          right: window.innerWidth,
          bottom: window.innerHeight,
          width: window.innerWidth,
          height: window.innerHeight
        };

        setup(function() {
          parent = fixture('constrain-target');
          parentRect = parent.getBoundingClientRect();
          el = dom(parent).querySelector('.el');
          elRect = el.getBoundingClientRect();
        });

        test('intersects works', function() {
          var base = {top: 0, bottom: 1, left: 0, right: 1};
          assert.isTrue(intersects(base, base), 'intersects itself');
          assert.isFalse(
              intersects(base, {top: 1, bottom: 2, left: 0, right: 1}),
              'no intersect on edge');
          assert.isFalse(
              intersects(base, {top: -2, bottom: -1, left: 0, right: 1}),
              'no intersect on edge (negative values)');
          assert.isFalse(
              intersects(base, {top: 2, bottom: 3, left: 0, right: 1}),
              'no intersect');
        });

        suite('when verticalAlign is top', function() {
          test('element is aligned to the positionTarget top', function() {
            el.verticalAlign = 'top';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.top, parentRect.top, 'top ok');
            assert.equal(rect.height, elRect.height, 'no cropping');
          });

          test(
              'element is aligned to the positionTarget top without overlapping it',
              function() {
                // Allow enough space on the parent's bottom & right.
                parent.style.width = '10px';
                parent.style.height = '10px';
                parentRect = parent.getBoundingClientRect();
                el.verticalAlign = 'top';
                el.noOverlap = true;
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.isFalse(intersects(rect, parentRect), 'no overlap');
                assert.equal(rect.height, elRect.height, 'no cropping');
              });

          test('element margin is considered as offset', function() {
            el.verticalAlign = 'top';
            el.style.marginTop = '10px';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.top, parentRect.top + 10, 'top ok');
            assert.equal(rect.height, elRect.height, 'no cropping');

            el.style.marginTop = '-10px';
            el.refit();
            rect = el.getBoundingClientRect();
            assert.equal(rect.top, parentRect.top - 10, 'top ok');
            assert.equal(rect.height, elRect.height, 'no cropping');
          });

          test('verticalOffset is applied', function() {
            el.verticalAlign = 'top';
            el.verticalOffset = 10;
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.top, parentRect.top + 10, 'top ok');
            assert.equal(rect.height, elRect.height, 'no cropping');
          });

          test('element is kept in viewport', function() {
            el.verticalAlign = 'top';
            // Make it go out of screen
            el.verticalOffset = -1000;
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.top, 0, 'top in viewport');
            assert.isTrue(rect.height < elRect.height, 'reduced size');
          });

          test('negative verticalOffset does not crop element', function() {
            // Push to the bottom of the screen.
            parent.style.top = (window.innerHeight - 50) + 'px';
            el.verticalAlign = 'top';
            el.verticalOffset = -10;
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.top, window.innerHeight - 60, 'top ok');
            assert.equal(rect.bottom, window.innerHeight, 'bottom ok');
          });

          test('max-height is updated', function() {
            parent.style.top = '-10px';
            el.verticalAlign = 'top';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.top, 0, 'top ok');
            assert.isBelow(rect.height, elRect.height, 'height ok');
          });

          test(
              'min-height is preserved: element is displayed even if partially',
              function() {
                parent.style.top = '-10px';
                el.verticalAlign = 'top';
                el.style.minHeight = elRect.height + 'px';
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.equal(rect.top, 0, 'top ok');
                assert.equal(rect.height, elRect.height, 'min-height ok');
                assert.isTrue(intersects(rect, fitRect), 'partially visible');
              });

          test(
              'dynamicAlign will prefer bottom align if it minimizes the cropping',
              function() {
                parent.style.top = '-10px';
                parentRect = parent.getBoundingClientRect();
                el.verticalAlign = 'top';
                el.dynamicAlign = true;
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.equal(rect.bottom, parentRect.bottom, 'bottom ok');
                assert.equal(rect.height, elRect.height, 'no cropping');
              });
        });

        suite('when verticalAlign is bottom', function() {
          test('element is aligned to the positionTarget bottom', function() {
            el.verticalAlign = 'bottom';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.bottom, parentRect.bottom, 'bottom ok');
            assert.equal(rect.height, elRect.height, 'no cropping');
          });

          test(
              'element is aligned to the positionTarget bottom without overlapping it',
              function() {
                el.verticalAlign = 'bottom';
                el.noOverlap = true;
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.isFalse(intersects(rect, parentRect), 'no overlap');
                assert.equal(rect.height, elRect.height, 'no cropping');
              });

          test('element margin is considered as offset', function() {
            el.verticalAlign = 'bottom';
            el.style.marginBottom = '10px';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.bottom, parentRect.bottom - 10, 'bottom ok');
            assert.equal(rect.height, elRect.height, 'no cropping');

            el.style.marginBottom = '-10px';
            el.refit();
            rect = el.getBoundingClientRect();
            assert.equal(rect.bottom, parentRect.bottom + 10, 'bottom ok');
            assert.equal(rect.height, elRect.height, 'no cropping');
          });

          test('verticalOffset is applied', function() {
            el.verticalAlign = 'bottom';
            el.verticalOffset = 10;
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.bottom, parentRect.bottom - 10, 'bottom ok');
            assert.equal(rect.height, elRect.height, 'no cropping');
          });

          test('element is kept in viewport', function() {
            el.verticalAlign = 'bottom';
            // Make it go out of screen
            el.verticalOffset = 1000;
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.top, 0, 'top in viewport');
            assert.isTrue(rect.height < elRect.height, 'reduced size');
          });

          test('element max-height is updated', function() {
            parent.style.top = (100 - parentRect.height) + 'px';
            el.verticalAlign = 'bottom';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.bottom, 100, 'bottom ok');
            assert.equal(rect.height, 100, 'height ok');
          });

          test(
              'min-height is preserved: element is displayed even if partially',
              function() {
                parent.style.top = (elRect.height - 10 - parentRect.height) + 'px';
                el.verticalAlign = 'bottom';
                el.style.minHeight = elRect.height + 'px';
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.equal(rect.top, 0, 'top ok');
                assert.equal(rect.height, elRect.height, 'min-height ok');
                assert.isTrue(intersects(rect, fitRect), 'partially visible');
              });

          test(
              'dynamicAlign will prefer top align if it minimizes the cropping',
              function() {
                parent.style.top = (window.innerHeight - elRect.height) + 'px';
                parentRect = parent.getBoundingClientRect();
                el.verticalAlign = 'bottom';
                el.dynamicAlign = true;
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.equal(rect.top, parentRect.top, 'top ok');
                assert.equal(rect.height, elRect.height, 'no cropping');
              });
        });

        suite('when verticalAlign is middle', function() {
          test('element is aligned to the positionTarget middle', function() {
            el.verticalAlign = 'middle';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(
                rect.top,
                parentRect.top + (parentRect.height - rect.height) / 2,
                'top ok');
            assert.equal(rect.height, elRect.height, 'no cropping');
          });

          test(
              'element is aligned to the positionTarget top without overlapping it',
              function() {
                // Allow enough space on the parent's bottom & right.
                el.verticalAlign = 'middle';
                el.noOverlap = true;
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.isFalse(intersects(rect, parentRect), 'no overlap');
                assert.equal(rect.height, elRect.height, 'no cropping');
              });

          test('element margin is considered as offset', function() {
            el.verticalAlign = 'middle';
            el.style.marginTop = '10px';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(
                rect.top,
                parentRect.top + (parentRect.height - rect.height) / 2 + 10,
                'top ok');
            assert.equal(rect.height, elRect.height, 'no cropping');

            el.style.marginTop = '-10px';
            el.refit();
            rect = el.getBoundingClientRect();
            assert.equal(
                rect.top,
                parentRect.top + (parentRect.height - rect.height) / 2 - 10,
                'top ok');
            assert.equal(rect.height, elRect.height, 'no cropping');
          });

          test('verticalOffset is applied', function() {
            el.verticalAlign = 'middle';
            el.verticalOffset = 10;
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(
                rect.top,
                parentRect.top + (parentRect.height - rect.height) / 2 + 10,
                'top ok');
            assert.equal(rect.height, elRect.height, 'no cropping');
          });

          test('element is kept in viewport', function() {
            el.verticalAlign = 'middle';
            // Make it go out of screen
            el.verticalOffset = -1000;
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.top, 0, 'top in viewport');
            assert.isTrue(rect.height < elRect.height, 'reduced size');
          });

          test('negative verticalOffset does not crop element', function() {
            // Push to the bottom of the screen.
            parent.style.top = (window.innerHeight - 50) + 'px';
            el.verticalAlign = 'middle';
            el.verticalOffset = -10;
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.top, window.innerHeight - 35, 'top ok');
            assert.equal(rect.bottom, window.innerHeight, 'bottom ok');
          });

          test('max-height is updated', function() {
            parent.style.top = '-50px';
            el.verticalAlign = 'middle';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.top, 0, 'top ok');
            assert.isBelow(rect.height, elRect.height, 'height ok');
          });

          test(
              'min-height is preserved: element is displayed even if partially',
              function() {
                parent.style.top = '-50px';
                el.verticalAlign = 'middle';
                el.style.minHeight = elRect.height + 'px';
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.equal(rect.top, 0, 'top ok');
                assert.equal(rect.height, elRect.height, 'min-height ok');
                assert.isTrue(intersects(rect, fitRect), 'partially visible');
              });

          test(
              'dynamicAlign will prefer bottom align if it minimizes the cropping',
              function() {
                parent.style.top = '-50px';
                parentRect = parent.getBoundingClientRect();
                el.verticalAlign = 'middle';
                el.dynamicAlign = true;
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.equal(rect.bottom, parentRect.bottom, 'bottom ok');
                assert.equal(rect.height, elRect.height, 'no cropping');
              });
        });

        suite('when verticalAlign is auto', function() {
          test('element is aligned to the positionTarget top', function() {
            el.verticalAlign = 'auto';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.top, parentRect.top, 'auto aligned to top');
            assert.equal(rect.height, elRect.height, 'no cropping');
          });

          test(
              'element is aligned to the positionTarget top without overlapping it',
              function() {
                // Allow enough space on the parent's bottom & right.
                parent.style.width = '10px';
                parent.style.height = '10px';
                parentRect = parent.getBoundingClientRect();
                el.verticalAlign = 'auto';
                el.noOverlap = true;
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.equal(rect.height, elRect.height, 'no cropping');
                assert.isFalse(intersects(rect, parentRect), 'no overlap');
              });

          test(
              'bottom is preferred to top if it diminishes the cropped area',
              function() {
                // This would cause a cropping of the element, so it should
                // automatically align to the bottom to avoid it.
                parent.style.top = '-10px';
                parentRect = parent.getBoundingClientRect();
                el.verticalAlign = 'auto';
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.equal(
                    rect.bottom, parentRect.bottom, 'auto aligned to bottom');
                assert.equal(rect.height, elRect.height, 'no cropping');
              });

          test(
              'bottom is preferred to top if it diminishes the cropped area, without overlapping positionTarget',
              function() {
                // This would cause a cropping of the element, so it should
                // automatically align to the bottom to avoid it.
                parent.style.top = '-10px';
                parentRect = parent.getBoundingClientRect();
                el.verticalAlign = 'auto';
                el.noOverlap = true;
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.equal(rect.height, elRect.height, 'no cropping');
                assert.isFalse(intersects(rect, parentRect), 'no overlap');
              });
        });

        suite('when horizontalAlign is left', function() {
          test('element is aligned to the positionTarget left', function() {
            el.horizontalAlign = 'left';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.left, parentRect.left, 'left ok');
            assert.equal(rect.width, elRect.width, 'no cropping');
          });

          test(
              'element is aligned to the positionTarget left without overlapping it',
              function() {
                // Make space at the parent's right.
                parent.style.width = '10px';
                parentRect = parent.getBoundingClientRect();
                el.horizontalAlign = 'left';
                el.noOverlap = true;
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.isFalse(intersects(rect, parentRect), 'no overlap');
                assert.equal(rect.width, elRect.width, 'no cropping');
              });

          test('element margin is considered as offset', function() {
            el.horizontalAlign = 'left';
            el.style.marginLeft = '10px';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.left, parentRect.left + 10, 'left ok');
            assert.equal(rect.width, elRect.width, 'no cropping');

            el.style.marginLeft = '-10px';
            el.refit();
            rect = el.getBoundingClientRect();
            assert.equal(rect.left, parentRect.left - 10, 'left ok');
            assert.equal(rect.width, elRect.width, 'no cropping');
          });

          test('horizontalOffset is applied', function() {
            el.horizontalAlign = 'left';
            el.horizontalOffset = 10;
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.left, parentRect.left + 10, 'left ok');
            assert.equal(rect.width, elRect.width, 'no cropping');
          });

          test('element is kept in viewport', function() {
            el.horizontalAlign = 'left';
            // Make it go out of screen.
            el.horizontalOffset = -1000;
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.left, 0, 'left in viewport');
            assert.isTrue(rect.width < elRect.width, 'reduced size');
          });

          test('negative horizontalOffset does not crop element', function() {
            // Push to the bottom of the screen.
            parent.style.left = (window.innerWidth - 50) + 'px';
            el.horizontalAlign = 'left';
            el.horizontalOffset = -10;
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.left, window.innerWidth - 60, 'left ok');
            assert.equal(rect.right, window.innerWidth, 'right ok');
          });

          test('element max-width is updated', function() {
            parent.style.left = '-10px';
            el.horizontalAlign = 'left';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.left, 0, 'left ok');
            assert.isBelow(rect.width, elRect.width, 'width ok');
          });

          test(
              'min-width is preserved: element is displayed even if partially',
              function() {
                parent.style.left = '-10px';
                el.style.minWidth = elRect.width + 'px';
                el.horizontalAlign = 'left';
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.equal(rect.left, 0, 'left ok');
                assert.equal(rect.width, elRect.width, 'min-width ok');
                assert.isTrue(intersects(rect, fitRect), 'partially visible');
              });

          test(
              'dynamicAlign will prefer right align if it minimizes the cropping',
              function() {
                parent.style.left = '-10px';
                parentRect = parent.getBoundingClientRect();
                el.horizontalAlign = 'left';
                el.dynamicAlign = true;
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.equal(rect.right, parentRect.right, 'right ok');
                assert.equal(rect.height, elRect.height, 'no cropping');
              });
        });

        suite('when horizontalAlign is right', function() {
          test('element is aligned to the positionTarget right', function() {
            el.horizontalAlign = 'right';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.right, parentRect.right, 'right ok');
            assert.equal(rect.width, elRect.width, 'no cropping');
          });

          test(
              'element is aligned to the positionTarget right without overlapping it',
              function() {
                // Make space at the parent's left.
                parent.style.left = elRect.width + 'px';
                parentRect = parent.getBoundingClientRect();
                el.horizontalAlign = 'right';
                el.noOverlap = true;
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.isFalse(intersects(rect, parentRect), 'no overlap');
                assert.equal(rect.width, elRect.width, 'no cropping');
              });

          test('element margin is considered as offset', function() {
            el.horizontalAlign = 'right';
            el.style.marginRight = '10px';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.right, parentRect.right - 10, 'right ok');
            assert.equal(rect.width, elRect.width, 'no cropping');

            el.style.marginRight = '-10px';
            el.refit();
            rect = el.getBoundingClientRect();
            assert.equal(rect.right, parentRect.right + 10, 'right ok');
            assert.equal(rect.width, elRect.width, 'no cropping');
          });

          test('horizontalOffset is applied', function() {
            el.horizontalAlign = 'right';
            el.horizontalOffset = 10;
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.right, parentRect.right - 10, 'right ok');
            assert.equal(rect.width, elRect.width, 'no cropping');
          });

          test('element is kept in viewport', function() {
            el.horizontalAlign = 'right';
            // Make it go out of screen.
            el.horizontalOffset = 1000;
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.left, 0, 'left in viewport');
            assert.isTrue(rect.width < elRect.width, 'reduced width');
          });

          test('element max-width is updated', function() {
            parent.style.left = (100 - parentRect.width) + 'px';
            el.horizontalAlign = 'right';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.right, 100, 'right ok');
            assert.equal(rect.width, 100, 'width ok');
          });

          test(
              'min-width is preserved: element is displayed even if partially',
              function() {
                parent.style.left = (elRect.width - 10 - parentRect.width) + 'px';
                el.horizontalAlign = 'right';
                el.style.minWidth = elRect.width + 'px';
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.equal(rect.left, 0, 'left ok');
                assert.equal(rect.width, elRect.width, 'min-width ok');
                assert.isTrue(intersects(rect, fitRect), 'partially visible');
              });

          test(
              'dynamicAlign will prefer left align if it minimizes the cropping',
              function() {
                parent.style.left = (window.innerWidth - elRect.width) + 'px';
                parentRect = parent.getBoundingClientRect();
                el.horizontalAlign = 'right';
                el.dynamicAlign = true;
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.equal(rect.left, parentRect.left, 'left ok');
                assert.equal(rect.height, elRect.height, 'no cropping');
              });
        });

        suite('when horizontalAlign is center', function() {
          test('element is aligned to the positionTarget center', function() {
            el.horizontalAlign = 'center';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(
                rect.left,
                parentRect.left + (parentRect.width - rect.width) / 2,
                'left ok');
            assert.equal(rect.width, elRect.width, 'no cropping');
          });

          test(
              'element is aligned to the positionTarget left without overlapping it',
              function() {
                el.horizontalAlign = 'center';
                el.noOverlap = true;
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.isFalse(intersects(rect, parentRect), 'no overlap');
                assert.equal(rect.width, elRect.width, 'no cropping');
              });

          test('element margin is considered as offset', function() {
            el.horizontalAlign = 'center';
            el.style.marginLeft = '10px';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(
                rect.left,
                parentRect.left + (parentRect.width - rect.width) / 2 + 10,
                'left ok');
            assert.equal(rect.width, elRect.width, 'no cropping');

            el.style.marginLeft = '-10px';
            el.refit();
            rect = el.getBoundingClientRect();
            assert.equal(
                rect.left,
                parentRect.left + (parentRect.width - rect.width) / 2 - 10,
                'left ok');
            assert.equal(rect.width, elRect.width, 'no cropping');
          });

          test('horizontalOffset is applied', function() {
            el.horizontalAlign = 'center';
            el.horizontalOffset = 10;
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(
                rect.left,
                parentRect.left + (parentRect.width - rect.width) / 2 + 10,
                'left ok');
            assert.equal(rect.width, elRect.width, 'no cropping');
          });

          test('element is kept in viewport', function() {
            el.horizontalAlign = 'center';
            // Make it go out of screen.
            el.horizontalOffset = -1000;
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.left, 0, 'left in viewport');
            assert.isTrue(rect.width < elRect.width, 'reduced size');
          });

          test('negative horizontalOffset does not crop element', function() {
            // Push to the bottom of the screen.
            parent.style.left = (window.innerWidth - 50) + 'px';
            el.horizontalAlign = 'center';
            el.horizontalOffset = -10;
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.left, window.innerWidth - 35, 'left ok');
            assert.equal(rect.right, window.innerWidth, 'right ok');
          });

          test('element max-width is updated', function() {
            parent.style.left = '-50px';
            el.horizontalAlign = 'center';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.left, 0, 'left ok');
            assert.isBelow(rect.width, elRect.width, 'width ok');
          });

          test(
              'min-width is preserved: element is displayed even if partially',
              function() {
                parent.style.left = '-50px';
                el.style.minWidth = elRect.width + 'px';
                el.horizontalAlign = 'center';
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.equal(rect.left, 0, 'left ok');
                assert.equal(rect.width, elRect.width, 'min-width ok');
                assert.isTrue(intersects(rect, fitRect), 'partially visible');
              });

          test(
              'dynamicAlign will prefer right align if it minimizes the cropping',
              function() {
                parent.style.left = '-50px';
                parentRect = parent.getBoundingClientRect();
                el.horizontalAlign = 'center';
                el.dynamicAlign = true;
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.equal(rect.right, parentRect.right, 'right ok');
                assert.equal(rect.height, elRect.height, 'no cropping');
              });
        });

        suite('when horizontalAlign is auto', function() {
          test('element is aligned to the positionTarget left', function() {
            el.horizontalAlign = 'auto';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.left, parentRect.left, 'auto aligned to left');
            assert.equal(rect.width, elRect.width, 'no cropping');
          });

          test(
              'element is aligned to the positionTarget left without overlapping positionTarget',
              function() {
                // Make space at the parent's left.
                parent.style.left = elRect.width + 'px';
                parentRect = parent.getBoundingClientRect();
                el.horizontalAlign = 'auto';
                el.noOverlap = true;
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.equal(rect.width, elRect.width, 'no cropping');
                assert.isFalse(intersects(rect, parentRect), 'no overlap');
              });

          test(
              'right is preferred to left if it diminishes the cropped area',
              function() {
                // This would cause a cropping of the element, so it should
                // automatically align to the right to avoid it.
                parent.style.left = '-10px';
                parentRect = parent.getBoundingClientRect();
                el.horizontalAlign = 'auto';
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.equal(rect.right, parentRect.right, 'auto aligned to right');
                assert.equal(rect.width, elRect.width, 'no cropping');
              });

          test(
              'right is preferred to left if it diminishes the cropped area, without overlapping positionTarget',
              function() {
                // Make space at the parent's right.
                parent.style.width = '10px';
                parentRect = parent.getBoundingClientRect();
                el.horizontalAlign = 'auto';
                el.noOverlap = true;
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.equal(rect.width, elRect.width, 'no cropping');
                assert.isFalse(intersects(rect, parentRect), 'no overlap');
              });
        });

        suite(
            'when horizontalAlign is center and verticalAling is middle', function() {
              test('element is aligned to the positionTarget center', function() {
                el.horizontalAlign = 'center';
                el.verticalAlign = 'middle';
                el.refit();
                var rect = el.getBoundingClientRect();
                assert.equal(
                    rect.left,
                    parentRect.left + (parentRect.width - rect.width) / 2,
                    'left ok');
                assert.equal(
                    rect.top,
                    parentRect.top + (parentRect.height - rect.height) / 2,
                    'top ok');
                assert.equal(rect.width, elRect.width, 'no cropping');
              });
            });

        suite('prefer horizontal overlap to vertical overlap', function() {
          setup(function() {
            el.noOverlap = true;
            el.dynamicAlign = true;
            // Make space around the positionTarget.
            parent.style.top = elRect.height + 'px';
            parent.style.left = elRect.width + 'px';
            parent.style.width = '10px';
            parent.style.height = '10px';
            parentRect = parent.getBoundingClientRect();
          });

          test('top-left aligns to target bottom-left', function() {
            el.verticalAlign = 'top';
            el.horizontalAlign = 'left';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.left, parentRect.left, 'left ok');
            assert.equal(rect.top, parentRect.bottom, 'top ok');
          });

          test('top-right aligns to target bottom-right', function() {
            el.verticalAlign = 'top';
            el.horizontalAlign = 'right';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.right, parentRect.right, 'right ok');
            assert.equal(rect.top, parentRect.bottom, 'top ok');
          });

          test('bottom-left aligns to target top-left', function() {
            el.verticalAlign = 'bottom';
            el.horizontalAlign = 'left';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.left, parentRect.left, 'left ok');
            assert.equal(rect.bottom, parentRect.top, 'bottom ok');
          });

          test('bottom-right aligns to target top-right', function() {
            el.verticalAlign = 'bottom';
            el.horizontalAlign = 'right';
            el.refit();
            var rect = el.getBoundingClientRect();
            assert.equal(rect.right, parentRect.right, 'right ok');
            assert.equal(rect.bottom, parentRect.top, 'bottom ok');
          });
        });
      });

      suite('expand-sizing-target-for-scrollbars', function() {
        let el;

        setup(function() {
          el = fixture('expandSizingTargetForScrollbars');
        });

        test('Vertical scrollbar size is added when top-left aligned.', function() {
          const tallDiv = document.createElement('div');
          tallDiv.style.height = '100px';
          el.appendChild(tallDiv);

          el.positionTarget = document.getElementById('nearBottom');
          el.verticalAlign = 'top';
          el.horizontalAlign = 'left';
          el.fit();

          if (hasOverflowAutoWidthBug) {
            // With this bug, the scrollbar will overflow by the scrollbar width
            // minus the right padding.
            const paddingRight = parseFloat(getComputedStyle(el).paddingRight, 10);
            const rightOverflow = scrollbarSize.width - paddingRight;
            assert.closeTo(el.clientWidth + rightOverflow, el.scrollWidth, 1);
          } else {
            // The element does not horizontally overflow when expanded by
            // the scrollbar size.
            assert.closeTo(el.clientWidth, el.scrollWidth, 1);
          }

          const positionTargetRect = el.positionTarget.getBoundingClientRect();
          const elRect = el.getBoundingClientRect();

          // The element is still top-left aligned.
          assert.closeTo(positionTargetRect.left, elRect.left, 1);

          if (hasOverflowAutoWidthBug) {
            // With this bug, the element will be expanded downwards, then
            // shifted upwards by the scrollbar size.
            const scrollbarSize = el.offsetHeight - el.clientHeight;
            assert.closeTo(positionTargetRect.top - scrollbarSize, elRect.top, 1);
          } else {
            assert.closeTo(positionTargetRect.top, elRect.top, 1);
          }
        });

        test('Vertical scrollbar size is added when top-center aligned.', function() {
          const tallDiv = document.createElement('div');
          tallDiv.style.height = '100px';
          el.appendChild(tallDiv);

          el.positionTarget = document.getElementById('nearBottom');
          el.verticalAlign = 'top';
          el.horizontalAlign = 'center';
          el.fit();

          if (hasOverflowAutoWidthBug) {
            // With this bug, the scrollbar will overflow by the scrollbar width
            // minus the right padding.
            const paddingRight = parseFloat(getComputedStyle(el).paddingRight, 10);
            const rightOverflow = scrollbarSize.width - paddingRight;
            assert.closeTo(el.clientWidth + rightOverflow, el.scrollWidth, 1);
          } else {
            // The element does not horizontally overflow when expanded by
            // the scrollbar size.
            assert.closeTo(el.clientWidth, el.scrollWidth, 1);
          }

          const positionTargetRect = el.positionTarget.getBoundingClientRect();
          const elRect = el.getBoundingClientRect();

          // The element is still top-center aligned.

          const positionTargetCenter =
              (positionTargetRect.left + positionTargetRect.right) / 2;
          const elCenter = (elRect.left + elRect.right) / 2;

          if (hasVerticalScrollbarMaxWidthBug) {
            // With this bug, the vertical scrollbar is not placed inside
            // the area constrained by `max-width`.
            assert.closeTo(
                positionTargetCenter, elCenter - scrollbarSize.width / 2, 1);
          } else {
            assert.closeTo(positionTargetCenter, elCenter, 1);
          }

          if (hasOverflowAutoWidthBug) {
            // With this bug, the element will be expanded downwards, then
            // shifted upwards by the scrollbar size.
            const scrollbarSize = el.offsetHeight - el.clientHeight;
            assert.closeTo(positionTargetRect.top - scrollbarSize, elRect.top, 1);
          } else {
            assert.closeTo(positionTargetRect.top, elRect.top, 1);
          }
        });

        test('Vertical scrollbar size is added when top-right aligned.', function() {
          const tallDiv = document.createElement('div');
          tallDiv.style.height = '100px';
          el.appendChild(tallDiv);

          el.positionTarget = document.getElementById('nearBottom');
          el.verticalAlign = 'top';
          el.horizontalAlign = 'right';
          el.fit();

          if (hasOverflowAutoWidthBug) {
            // With this bug, the scrollbar will overflow by the scrollbar width
            // minus the right padding.
            const paddingRight = parseFloat(getComputedStyle(el).paddingRight, 10);
            const rightOverflow = scrollbarSize.width - paddingRight;
            assert.closeTo(el.clientWidth + rightOverflow, el.scrollWidth, 1);
          } else {
            // The element does not horizontally overflow when expanded by
            // the scrollbar size.
            assert.closeTo(el.clientWidth, el.scrollWidth, 1);
          }

          const positionTargetRect = el.positionTarget.getBoundingClientRect();
          const elRect = el.getBoundingClientRect();

          // The element is still top-left aligned.

          if (hasVerticalScrollbarMaxWidthBug) {
            // With this bug, the vertical scrollbar is not placed inside
            // the area constrained by `max-width`.
            assert.closeTo(
                positionTargetRect.right, elRect.right - scrollbarSize.width, 1);
          } else {
            assert.closeTo(positionTargetRect.right, elRect.right, 1);
          }

          if (hasOverflowAutoWidthBug) {
            // With this bug, the element will be expanded downwards, then
            // shifted upwards by the scrollbar size.
            const scrollbarSize = el.offsetHeight - el.clientHeight;
            assert.closeTo(positionTargetRect.top - scrollbarSize, elRect.top, 1);
          } else {
            assert.closeTo(positionTargetRect.top, elRect.top, 1);
          }
        });

        test(
            'Vertical scrollbar size is added when bottom-left aligned.', function() {
              const tallDiv = document.createElement('div');
              tallDiv.style.height = '100px';
              el.appendChild(tallDiv);

              el.positionTarget = document.getElementById('nearTop');
              el.verticalAlign = 'bottom';
              el.horizontalAlign = 'left';
              el.fit();

              if (hasOverflowAutoWidthBug) {
                // With this bug, the scrollbar will overflow by the scrollbar width
                // minus the right padding.
                const paddingRight =
                    parseFloat(getComputedStyle(el).paddingRight, 10);
                const rightOverflow = scrollbarSize.width - paddingRight;
                assert.closeTo(el.clientWidth + rightOverflow, el.scrollWidth, 1);
              } else {
                // The element does not horizontally overflow when expanded by
                // the scrollbar size.
                assert.closeTo(el.clientWidth, el.scrollWidth, 1);
              }

              const positionTargetRect = el.positionTarget.getBoundingClientRect();
              const elRect = el.getBoundingClientRect();

              // The element is still bottom-left aligned.
              assert.closeTo(positionTargetRect.left, elRect.left, 1);

              if (hasOverflowAutoWidthBug) {
                // With this bug, the element will be expanded downwards.
                const scrollbarSize = el.offsetHeight - el.clientHeight;
                assert.closeTo(
                    positionTargetRect.bottom + scrollbarSize, elRect.bottom, 1);
              } else {
                assert.closeTo(positionTargetRect.bottom, elRect.bottom, 1);
              }
            });

        test(
            'Vertical scrollbar size is added when bottom-center aligned.',
            function() {
              const tallDiv = document.createElement('div');
              tallDiv.style.height = '100px';
              el.appendChild(tallDiv);

              el.positionTarget = document.getElementById('nearTop');
              el.verticalAlign = 'bottom';
              el.horizontalAlign = 'center';
              el.fit();

              if (hasOverflowAutoWidthBug) {
                // With this bug, the scrollbar will overflow by the scrollbar width
                // minus the right padding.
                const paddingRight =
                    parseFloat(getComputedStyle(el).paddingRight, 10);
                const rightOverflow = scrollbarSize.width - paddingRight;
                assert.closeTo(el.clientWidth + rightOverflow, el.scrollWidth, 1);
              } else {
                // The element does not horizontally overflow when expanded by
                // the scrollbar size.
                assert.closeTo(el.clientWidth, el.scrollWidth, 1);
              }

              const positionTargetRect = el.positionTarget.getBoundingClientRect();
              const elRect = el.getBoundingClientRect();

              // The element is still bottom-center aligned.
              const positionTargetCenter =
                  (positionTargetRect.left + positionTargetRect.right) / 2;
              const elCenter = (elRect.left + elRect.right) / 2;

              if (hasVerticalScrollbarMaxWidthBug) {
                // With this bug, the vertical scrollbar is not placed inside
                // the area constrained by `max-width`.
                assert.closeTo(
                    positionTargetCenter, elCenter - scrollbarSize.width / 2, 1);
              } else {
                assert.closeTo(positionTargetCenter, elCenter, 1);
              }

              if (hasOverflowAutoWidthBug) {
                // With this bug, the element will be expanded downwards.
                const scrollbarSize = el.offsetHeight - el.clientHeight;
                assert.closeTo(
                    positionTargetRect.bottom + scrollbarSize, elRect.bottom, 1);
              } else {
                assert.closeTo(positionTargetRect.bottom, elRect.bottom, 1);
              }
            });

        test(
            'Vertical scrollbar size is added when bottom-right aligned.',
            function() {
              const tallDiv = document.createElement('div');
              tallDiv.style.height = '100px';
              el.appendChild(tallDiv);

              el.positionTarget = document.getElementById('nearTop');
              el.verticalAlign = 'bottom';
              el.horizontalAlign = 'right';
              el.fit();

              if (hasOverflowAutoWidthBug) {
                // With this bug, the scrollbar will overflow by the scrollbar width
                // minus the right padding.
                const paddingRight =
                    parseFloat(getComputedStyle(el).paddingRight, 10);
                const rightOverflow = scrollbarSize.width - paddingRight;
                assert.closeTo(el.clientWidth + rightOverflow, el.scrollWidth, 1);
              } else {
                // The element does not horizontally overflow when expanded by
                // the scrollbar size.
                assert.closeTo(el.clientWidth, el.scrollWidth, 1);
              }

              const positionTargetRect = el.positionTarget.getBoundingClientRect();
              const elRect = el.getBoundingClientRect();

              // The element is still bottom-right aligned.

              if (hasVerticalScrollbarMaxWidthBug) {
                // With this bug, the vertical scrollbar is not placed inside
                // the area constrained by `max-width`.
                assert.closeTo(
                    positionTargetRect.right, elRect.right - scrollbarSize.width, 1);
              } else {
                assert.closeTo(positionTargetRect.right, elRect.right, 1);
              }

              if (hasOverflowAutoWidthBug) {
                // With this bug, the element will be expanded downwards.
                const scrollbarSize = el.offsetHeight - el.clientHeight;
                assert.closeTo(
                    positionTargetRect.bottom + scrollbarSize, elRect.bottom, 1);
              } else {
                assert.closeTo(positionTargetRect.bottom, elRect.bottom, 1);
              }
            });

        test('Horizontal scrollbar size is added when top-left aligned.', function() {
          const wideDiv = document.createElement('div');
          // Set height to 1px to work around a Safari rendering bug: without
          // this explicit height, the div does not contribute to the width of
          // the element.
          wideDiv.style.height = '1px';
          wideDiv.style.width = '100px';
          el.appendChild(wideDiv);

          el.positionTarget = document.getElementById('nearRight');
          el.verticalAlign = 'top';
          el.horizontalAlign = 'left';
          el.fit();

          // The element does not vertically overflow when expanded by the
          // scrollbar size.
          assert.closeTo(el.clientHeight, el.scrollHeight, 1);

          const positionTargetRect = el.positionTarget.getBoundingClientRect();
          const elRect = el.getBoundingClientRect();

          // The element is still top-left aligned.
          assert.closeTo(positionTargetRect.left, elRect.left, 1);
          assert.closeTo(positionTargetRect.top, elRect.top, 1);
        });

        test(
            'Horizontal scrollbar size is added when middle-left aligned.',
            function() {
              const wideDiv = document.createElement('div');
              // Set height to 1px to work around a Safari rendering bug:
              // without this explicit height, the div does not contribute to
              // the width of the element.
              wideDiv.style.height = '1px';
              wideDiv.style.width = '100px';
              el.appendChild(wideDiv);

              el.positionTarget = document.getElementById('nearRight');
              el.verticalAlign = 'middle';
              el.horizontalAlign = 'left';
              el.fit();

              // The element does not vertically overflow when expanded by the
              // scrollbar size.
              assert.closeTo(el.clientHeight, el.scrollHeight, 1);

              const positionTargetRect = el.positionTarget.getBoundingClientRect();
              const elRect = el.getBoundingClientRect();

              // The element is still middle-left aligned.
              const positionTargetHeight =
                  positionTargetRect.bottom - positionTargetRect.top;
              const elHeight = elRect.bottom - elRect.top;
              assert.closeTo(
                  positionTargetRect.top + positionTargetHeight / 2,
                  elRect.top + elHeight / 2,
                  1);
              assert.closeTo(positionTargetRect.left, elRect.left, 1);
            });

        test(
            'Horizontal scrollbar size is added when bottom-left aligned.',
            function() {
              const wideDiv = document.createElement('div');
              // Set height to 1px to work around a Safari rendering bug:
              // without this explicit height, the div does not contribute to
              // the width of the element.
              wideDiv.style.height = '1px';
              wideDiv.style.width = '100px';
              el.appendChild(wideDiv);

              el.positionTarget = document.getElementById('nearRight');
              el.verticalAlign = 'bottom';
              el.horizontalAlign = 'left';
              el.fit();

              // The element does not vertically overflow when expanded by the
              // scrollbar size.
              assert.closeTo(el.clientHeight, el.scrollHeight, 1);

              const positionTargetRect = el.positionTarget.getBoundingClientRect();
              const elRect = el.getBoundingClientRect();

              // The element is still bottom-left aligned.
              assert.closeTo(positionTargetRect.left, elRect.left, 1);
              assert.closeTo(positionTargetRect.bottom, elRect.bottom, 1);
            });

        test(
            'Horizontal scrollbar size is added when top-right aligned.', function() {
              const wideDiv = document.createElement('div');
              // Set height to 1px to work around a Safari rendering bug:
              // without this explicit height, the div does not contribute to
              // the width of the element.
              wideDiv.style.height = '1px';
              wideDiv.style.width = '100px';
              el.appendChild(wideDiv);

              el.positionTarget = document.getElementById('nearLeft');
              el.verticalAlign = 'top';
              el.horizontalAlign = 'right';
              el.fit();

              // The element does not vertically overflow when expanded by the
              // scrollbar size.
              assert.closeTo(el.clientHeight, el.scrollHeight, 1);

              const positionTargetRect = el.positionTarget.getBoundingClientRect();
              const elRect = el.getBoundingClientRect();

              // The element is still top-right aligned.
              assert.closeTo(positionTargetRect.right, elRect.right, 1);
              assert.closeTo(positionTargetRect.top, elRect.top, 1);
            });

        test(
            'Horizontal scrollbar size is added when middle-right aligned.',
            function() {
              const wideDiv = document.createElement('div');
              // Set height to 1px to work around a Safari rendering bug:
              // without this explicit height, the div does not contribute to
              // the width of the element.
              wideDiv.style.height = '1px';
              wideDiv.style.width = '100px';
              el.appendChild(wideDiv);

              el.positionTarget = document.getElementById('nearLeft');
              el.verticalAlign = 'middle';
              el.horizontalAlign = 'right';
              el.fit();

              // The element does not vertically overflow when expanded by the
              // scrollbar size.
              assert.closeTo(el.clientHeight, el.scrollHeight, 1);

              const positionTargetRect = el.positionTarget.getBoundingClientRect();
              const elRect = el.getBoundingClientRect();

              // The element is still middle-right aligned.
              const positionTargetHeight =
                  positionTargetRect.bottom - positionTargetRect.top;
              const elHeight = elRect.bottom - elRect.top;
              assert.closeTo(
                  positionTargetRect.top + positionTargetHeight / 2,
                  elRect.top + elHeight / 2,
                  1);
              assert.closeTo(positionTargetRect.right, elRect.right, 1);
            });

        test(
            'Horizontal scrollbar size is added when bottom-right aligned.',
            function() {
              const wideDiv = document.createElement('div');
              // Set height to 1px to work around a Safari rendering bug:
              // without this explicit height, the div does not contribute to
              // the width of the element.
              wideDiv.style.height = '1px';
              wideDiv.style.width = '100px';
              el.appendChild(wideDiv);

              el.positionTarget = document.getElementById('nearLeft');
              el.verticalAlign = 'bottom';
              el.horizontalAlign = 'right';
              el.fit();

              // The element does not vertically overflow when expanded by the
              // scrollbar size.
              assert.closeTo(el.clientHeight, el.scrollHeight, 1);

              const positionTargetRect = el.positionTarget.getBoundingClientRect();
              const elRect = el.getBoundingClientRect();

              // The element is still bottom-right aligned.
              assert.closeTo(positionTargetRect.right, elRect.right, 1);
              assert.closeTo(positionTargetRect.bottom, elRect.bottom, 1);
            });
      });
    </script>
  </body>
</html>
